<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>K2314767 - CI7825 - Connected Games Blog</title>
    <link rel="stylesheet" href="connectedGamesBlog.css">
    <link rel="stylesheet" href="../required.css">

    <script src="../required.js" defer></script>
    <link rel="icon" type="image/x-icon" href="Images/joystick.png">

    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github-dark.min.css">
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>

</head>

<body>
    <br>
    <h1>Developing Profit Pits</h1>
    <br>
    <h3 style="text-align: center;">Multiplayer and procedurally generated experiences crafted here, with Profit
        Pits!</h3>
    <p>
        I am <a href="../index.html" class="a1" target="_blank">Raghav Suriyashekar</a>, or as my friends call me,
        K2314767,
        part of Group 1 - Quarry Mines Inc.<br><br>
    </p>
    <p>
        Welcome to my development journey as a programmer in a team building a multiplayer game
        for the CI7825 Connected Games module as part of the MSc. Game Developement(Programming) course at Kingston
        University with an awesome co-developer <a href="https://requieem.github.io/#blog" class="a1" target="_blank">Marco Farace</a> 
        and amazing design team <a href="" class="a1" target="_blank">Roland Thomas</a>, 
        <a href="" class="a1" target="_blank">Achitphon Rungcharoenwikrai</a> and 
        <a href="" class="a1" target="_blank">Nana Baah</a>.<br>
        Check out my blog posts below to see the progress made so far.
    </p>
    <br><br>
    <div class="blog-container">

        <div class="blog-post" onclick="expandPost(this)">
            <h2>It has begun.</h2>
            <p class="date">February 8, 2025</p>
            <p>Core concept discussion. Arrived at a consensus for what the project would be, and more importantly, what
                us programmers need to do.</p>
            <a class="read-more">Read More</a>
            <div class="expanded-content">
                <p>
                    From the words of our designers, the game is :<br>
                    Profit Pits, a seamless collaborative game where the players are hired miners under Quarry Minds.inc where they must
                    explore the cave systems and aim to discover variety of ores to mine, become a well-oiled machine of teamwork in pursuit of wealth in mining by delivering the processed minerals to your employers to sell. 
                    <br><br>
                    My primary responsibility was the procedural generation, mesh generation and shaders.<br>
                    I built a novel algorithm to generate the cave system and the caves within it, which I will be discussing in the next post.<br>
                    I utilized compute shaders, shader graph and HLSL to create a responsive, performant and infinitely manipulable cave system.<br>
                    I also worked on the shader to visualize the caves and the cave system, which I will be discussing in a later post.<br>

                </p>
                <h3>LOTS AND LOTS AND LOTS OF PLANNING<br></h3>
                <p>
                    
                    We had many discussions about the game both during the initial stages and many during the development, as good games usually do.
                    We had many ideas and concepts that we wanted to implement, but we had to be realistic about the time we had and the scope of the project.
                    We used tools like Trello and Miro to plan out the project and the tasks we needed to do.<br>
                    Must mention Roland's amazing work setting up the Trello board and Miro board for us to use.<br>
                </p>
                <img src="Media/Post01/Img01.png">
                <img src="Media/Post01/Img02.png">
                <img src="Media/Post01/Img03.png">
                <img src="Media/Post01/Img04.png">
                <img src="Media/Post01/Img05.png">
                <img src="Media/Post01/Img06.png">
                <img src="Media/Post01/Img07.png">
                <img src="Media/Post01/Img08.png">
                <img src="Media/Post01/Img09.png">
                <p>
                    Glimpse of some of the planning we did for the project.<br><br>
                    THE PLAN WAS WRIT, ONTO DEVELOPMENT!!!!!!<br><br>
                </p>
            </div>
        </div>


        <div class="blog-post" onclick="expandPost(this)">
            <h2>The Pits</h2>
            <p class="date">February 8, 2025</p>
            <p>
                Building the procedurally generated caves.<br>This is going to be a challenge.
            </p>
            <a class="read-more">Read More</a>
            <div class="expanded-content">
                <p>
                    To build a cave, which is essentially a cavity, I wanted to explore creating an algorithm from
                    scratch.
                    Through some thought cycles, I settled on a custom solution, a method where volumes
                    are layered additively in stages to form a complex outer hull that defines the cave structure.<br>
                    I'm calling this method <strong style="color: rgb(255, 98, 0); font-weight:bolder">CAVE CASCADES</strong>.

                </p>
                <br>
                    <br>
                    <pre><code>
        PSEUDO CODE FOR THE CAVE CASCADES
        1. Define a base cascade volume.
        2. For every cascade stage iterated through with a depth value, append volumes along the surface of the previous cascade stage.
        3. Randomize between cuboidal and spherical voolumes in each stage.
        4. Encapsulate all the generated volumes to form a container.
                    </code></pre>
                <br>
                <p>
                    One of the intriguing techniques I've incorporated is the use of bit manipulation to select the
                    surface face around which the next cascade stage will be generated. This method ensures a high level
                    of precision in the algorithm.
                </p>
               
                <pre>
                    <code class="language-csharp">
    int randomPower = (int)Helper.Randomize(ref seed, ref output, 0f, 3f);
    int baseResult = (int)Mathf.Pow(2, randomPower);
    int requiredResult = 7 - baseResult;
                    </code>
                </pre>
                <p>
                    The random power generates a number between 0 and 2(inclusive). Raising 2 to this random power gives
                    1, 2, or 4.<br>
                    The binary representations of these numbers(shortened to 3 bits) are:<br>
                    1 : 001<br>
                    2 : 010<br>
                    4 : 100<br>
                    This step isolates an axis, as seen with 0 and 1, to position a cascade volume.
                    Subtracting these values from 7 results in outputs 3, 5, and 6, whose binary representations
                    are:<br>
                    3 : 011<br>
                    5 : 101<br>
                    6 : 110<br>
                    These subtracted values essentially remove the influence of the missing bit, confining the cascade
                    volume to its plane.
                    Randomizing the two dimensions of the coordinates on the plane gives a position to generate a
                    cascade.
                </p>
                <br>
                <img src="Media/Post02/CaveStage01.png">
                <img src="Media/Post02/CaveStage02.png">
                <img src="Media/Post02/CaveStage03.png">
                <br>
                <p>
                    The developing complexity of each cascade depth builds into the cave's volume.<br>
                    The resulting cave structure had good detail and organic looking structure but was very angular
                    without any smooth or curved areas, as caves usually feature.
                    Introducing spheres with each cascade depth to build the volume proved to be the perfect addition to
                    fleshing out the volume.
                </p>
                <br>
                <img src="Media/Post02/CaveStage04.png">
                <img src="Media/Post02/CaveStage05.png">
                <img src="Media/Post02/CaveStage06.png">
                <br>
                <p>
                    With the volume/cavity of the cave generated, the points lying within in a fixed spatial density
                    containing information about the volumes had to be derived.
                    The points generated in the compute shader contain the volume-bound information into Vector4 data
                    structured buffers.
                    The system uses thread IDs to calculate the appropriate indices, allowing
                    the system to generate points in a volume at a higher density than customarily computed.
                    The points in the coordinate system are generated and are closer to each other, allowing for higher
                    fidelity of the generated mesh in the following steps.
                </p>
                <br>
                    <pre><code class="language-csharp">
                        bool WithinBounds(float3 pos, float3 boundPos, float3 boundDim)
                        {
                            bool x = (pos.x < boundPos.x + boundDim.x * 0.5 && pos.x > boundPos.x - boundDim.x * 0.5);
                            bool y = (pos.y < boundPos.y + boundDim.y * 0.5 && pos.y > boundPos.y - boundDim.y * 0.5);
                            bool z = (pos.z < boundPos.z + boundDim.z * 0.5 && pos.z > boundPos.z - boundDim.z * 0.5);
                            
                            return x && y && z;
                        }
                        
                        [numthreads(3,3,3)]
                        void GenerateBoundedPoints (uint3 id : SV_DispatchThreadID)
                        {
                            int3 _bounds = ceil(bounds);
                            float3 pos = (id) / 3.0 + _position - _bounds * 0.5;
                            bool boundInNode = false;
                            bool boundInSNode = false;
                             
                            int n = id.x + id.y * 3 + id.z * 3 * 3;
                            int _index = id.x * 1 + id.y * 1 * 3 * _bounds.x + id.z * 1 * 3 * 3 * _bounds.y * _bounds.x;
                            
                            int i;
                            
                            bool boundInCavity = false;
                            bool boundInCamber = false;
                            
                            for (i = 0; i < cavityCount; i++)
                            {
                                boundInCavity = WithinBounds(pos, cavityPositions[i].xyz, cavityDimensions[i].xyz);
                                if (boundInCavity)
                                    i = cavityCount;
                            }
                            
                            for (i = 0; i < camberCount; i++)
                            {
                                boundInCamber = WithinBounds(pos, camberPositions[i].xyz, camberDimensions[i].xyz);
                                if (boundInCamber)
                                    i = camberCount;
                            }
                            
                            for (i = 0; i < nodeCount; i++)
                            {
                                boundInNode = WithinBounds(pos, nodePositions[i].xyz, nodeDimensions[i].xyz);
                                if (boundInNode)
                                    i = nodeCount;
                            }
                            
                            for (i = 0; i < sNodeCount; i++)
                            {
                                boundInSNode = distance(pos, sphericalNodes[i].xyz) < sphericalNodes[i].w;
                                if (boundInSNode)
                                    i = sNodeCount;
                            }
                        
                            if(boundInCavity)
                                positions[_index] = float4(pos, 1);
                            else if(boundInCamber)
                                positions[_index] = float4(pos, 0);
                            else
                                positions[_index] = float4(pos, ((boundInNode || boundInSNode) && pos.y > floorHeight) ? 1 : 0);
                              
                        }
                    </code></pre>
                <br>
                <p>
                    This comopute shader generated the points in a volume corresponding to if it is in the cave cascades or if it is manipulated by being inside a cavity or camber.<br>
                </p>
                <p>
                    The points generated by the compute shader, filtered out to only display those within the generated
                    cave volume.
                </p>
                <br>
                <img src="Media/Post02/CaveStage07.png">
                <br>
                <p>
                    The mesh generation is taken care of by the <strong style="color: rgb(255, 98, 0); font-weight:bolder">MARCHING CUBES</strong> algorithm.<br>
                    This algorithm uses the relative relationship between the 8 vertices of a cube to decide how the intermediate surface should be.
                    Based on the value of the whether the points are part of solid geometry or not. There are 256 permutations of how each vertex of a cube can be and how it's resulting surface would look like.<br>
                    This can further be optimized to 15 cases, as the cube is symmetric and the surface can be mirrored across the axes. The algorithm uses a lookup table to determine how the surface should be generated based on the values of the vertices.
                    <br>
                    <img src="Media/Post02/MarchingCubesCases.png"><br>
                    The previous points generation stage is crucial for optimal mesh generation by the Marching Cubes algorithm.
                    The density of the cells used by the Marching Cubes algorithm determines the quality and resolution of the generated mesh.<br>
                    <img src="Media/Post02/polygonise3.gif"><br>
                </p>
                <br>
                <p>
                    Wireframe of the generated caves.
                </p>
                <br>
                <img src="Media/Post02/CaveStage10.png">
                <img src="Media/Post02/CaveStage11.png">
                <img src="Media/Post02/CaveStage08.png">
                <img src="Media/Post02/CaveStage09.png">

                <p>
                    Caves when viewed from the inside and their wireframe representation.
                </p>
                <img src="Media/Post02/CaveInside.png">
                <img src="Media/Post02/CaveInsideWireFrame.png">

                <p>
                    Some examples of the caves generated using this method.
                </p>
                <img src="Media/Post02/CaveExample01.png">
                <img src="Media/Post02/CaveExample02.png">
                <img src="Media/Post02/CaveExample03.png">

            </div>
        </div>

        
        <div class="blog-post" onclick="expandPost(this)">
            <h2>Carving detail.</h2>
            <p class="date">February 19, 2025</p>
            <p>
                Manipulating the Cave Volume and Shape.
            </p>
            <a class="read-more">Read More</a>
            <div class="expanded-content">
                <p>
                    Procedurally generated seeded caves are a go! They have a moderate amout of detail and are within a
                    reasonable tri-count.<br>
                </p>
                <br> 
                <p>
                     Having seeded caves is very beneficial for the game, as it allows for a lot of flexibility in the design of the caves and the gameplay.<br>
                     However, any detail that needs to be intentional cannot be baked into the seed and/or the algorithm itself.<br>
                        This is where the next step comes in, where the cave volume can be manipulated to add detail and features to the cave.<br>
                    The cave volume can be manipulated in a few ways, such as:<br>
                    1. Defining a volume called "Cavities" that will remove parts of the cave that are within it.<br>
                    2. Defining a colume called "Cambers" that will add it's volume to the cave.
                </p>
                <h3>CAVITIES</h3>
                <p>
                    Using bounds to define the position and extends of the volume to be removed from the cave.<br>
                    <img src="Media/Post03/Cavities/Cave_NoCavities_01.png"><br>
                    <img src="Media/Post03/Cavities/Cave_Cavities_01.png"><br>
                    <img src="Media/Post03/Cavities/Cave_Cavities_02.png"><br>
                    <img src="Media/Post03/Cavities/Cave_Cavities_11.png"><br>
                    <img src="Media/Post03/Cavities/Cave_Cavities_12.png"><br>
                    <p>
                        With the cavities in place, the cave can be manipulated to have very specific features to accomodate for visual or gameplay related purposes.<br>
                    </p>
                </p>
                <h3>CAMBERS</h3>
                <p>
                    Similar to the cavities, bounds define the position and extends of the volume to be added into the cave.<br>
                    <img src="Media/Post03/Cambers/Cave_NoCambers_01.png"><br>
                    <img src="Media/Post03/Cambers/Cave_Cambers_01.png"><br>
                    <img src="Media/Post03/Cambers/Cave_Cambers_02.png"><br>
                </p>
                <h3>COMBINATION FOR BETTER DETAIL</h3>
                <p>
                    The cavities and cambers can be combined to create more complex shapes and features in the cave.<br>
                    
                    <img src="Media/Post03/Cave_Combo_01.png"><br>
                    <img src="Media/Post03/Cave_Combo_02.png"><br>
                    Like this tavern bar area built right into the cave structure.<br>
                    <img src="Media/Post03/Cave_Combo_03.png"><br>
                    <br>
                    With this, the designers have full control of parts of the cave that needs a fixed appearance.<br>
                    The designers can define the position and extends of the cavities and cambers to create a very specific look for the cave.<br>
                    This allows for a lot of flexibility in the design of the caves and the gameplay.<br><br><br><br>
                </p>
            </div>
        </div>


        <div class="blog-post" onclick="expandPost(this)">
            <h2>The expansion.</h2>
            <p class="date">February 23, 2025</p>
            <p>
                From Cavity to Cave.<br>
                From Cave to Cave system.
            </p>
            <a class="read-more">Read More</a>
            <div class="expanded-content">
                <p>
                    Caves have some organic looking detail and their volumes can be manipulated to add features and details.<br>
                    The next step would be to expand it to form a cave system so players can have a more immersive experience.<br>
                    The cave system is a 2D grid of caves in a layout defined by the syustem dimensions.<br><br>
                </p>
                <img src="Media/Post04/CaveSystem_04.png"><br><br>
                <p>
                    With the basic layout of the caves in place, we needed a way to connect the caves to each other.<br>
                    Fortunately, the cave manipulation can  also be used to create tunnels within the volumes. If we make each of the cave's bounds overlap with its neighbours, 
                    The cavities will join the caves together and create a tunnel between them.<br>
                    To generate the cavities that connect the caves, I first generate every axis-aligned connection between neighbouring caves.<br>
                    There will be <br>
                </p>    
                <h3>2 * M * N - (M + N)</h3>
                <p>
                    cave connections for a cave system with dimensions M and N.<br>
                    If we pick a random number < (M + N) from this collection of connections, we can randomize the cave network to be more organic with tis links and tunnels.<br>
                    This results in a overview that looks like this<br><br>
                </p>
                <img src="Media/Post04/CaveSystem_05.png"><br><br>
                <p>
                    Generating the caves with these cavities gives a nice cave system layout.<br>
                </p>
                <img src="Media/Post04/CaveSystem_06.png"><br><br>
                <img src="Media/Post04/CaveSystem_03.png"><br><br>
                <p>
                    The cave system generates in about 0.5 - 1 second and is very controllable in both the connections and dimensions.<br>
                </p>
                <img src="Media/Post04/CaveSystem_01.png"><br><br>
                <img src="Media/Post04/CaveSystem_02.png"><br><br>
                <p>
                    With a shader I developed to look into the caves(next post), it works out-of-the-box with the entire system as well.<br>
                </p>
                <img src="Media/Post04/CaveSystem_07.png"><br><br>
            </div>
        </div>


        <div class="blog-post" onclick="expandPost(this)">
            <h2>Looking into the pits.</h2>
            <p class="date">March 2, 2025</p>
            <p>
                Shader Magic ahead!
            </p>
            <a class="read-more">Read More</a>
            <div class="expanded-content">
                <p>

                </p>
            </div>
        </div>


        <div class="blog-post" onclick="expandPost(this)">
            <h2>Mineables and Poison</h2>
            <p class="date">March 14, 2025</p>
            <p>
                Populating the caves with mineables and poison.<br>
            </p>
            <a class="read-more">Read More</a>
            <div class="expanded-content">
                <p>

                </p>
            </div>
        </div>
        

        <div class="blog-post" onclick="expandPost(this)">
            <h2>DISASTER</h2>
            <p class="date">April 2, 2025</p>
            <p>
                WE RAN INTO A PROBLEM, and we need to BAKE THE CAVES.<br>
                I am upset.
            </p>
            <a class="read-more">Read More</a>
            <div class="expanded-content">
                
            </div>
        </div>


        <div class="blog-post" onclick="expandPost(this)">
            <h2>Fixes and Extras<h2>
            <p class="date">April 20, 2025</p>
            <p>
                Miscellaneous odd jobs to get it running.<br>
            </p>
            <a class="read-more">Read More</a>
            <div class="expanded-content">
                
            </div>
        </div>


        <div class="blog-post" onclick="expandPost(this)">
            <h2>Finishing Touches</h2>
            <p class="date">May 1, 2025</p>
            <p>
                THE CONCLUSION.
            </p>
            <a class="read-more">Read More</a>
            <div class="expanded-content">
                <p>
                    This project was awesome!<br>
                    Unfortunately, we don't have another month to work on it.<br>
                    Many things broke, had to be replaced, or sacrificed in scope to complete it, but it was an amazing learning experience.<br>
                    <br>
                    I am delighted to experiment with concepts and ideas I have been thinking about for a long time.<br>
                    Using compute shaders is something I always look forward to, and the tasks I implemented in this project helped me enhance not 
                    just my knowledge of compute shaders but the extent to which they can be used to create complex systems.<br> 
                   
                </p>
            </div>
        </div>

    </div>

    <br><br>
    <p>
        This blog site was made in HTML and CSS with some JavaScript to make it more interactive.<br>
        It is hosted on my Github pages site and will be up until I decide to re-write it.<br>
    </p>
    <br><br>

    <script>
        document.addEventListener("DOMContentLoaded", function () {
            const posts = document.querySelectorAll(".blog-post");
            let starredPosts = JSON.parse(localStorage.getItem("starredPosts")) || [];

            let overlay = document.createElement("div");
            overlay.classList.add("expanded-overlay");
            document.body.appendChild(overlay);

            function createStarElement(postId) {
                let star = document.createElement("span");
                star.classList.add("star");
                updateStarAppearance(star, postId);

                star.addEventListener("click", function (event) {
                    event.stopPropagation();

                    if (starredPosts.includes(postId)) {
                        starredPosts = starredPosts.filter(id => id !== postId);
                    } else {
                        starredPosts.push(postId);
                    }

                    localStorage.setItem("starredPosts", JSON.stringify(starredPosts));

                    document.querySelectorAll(`[data-post-id="${postId}"] .star`).forEach(s => {
                        updateStarAppearance(s, postId);
                    });

                    document.querySelectorAll(`[data-post-id="${postId}"]`).forEach(post => {
                        if (starredPosts.includes(postId)) {
                            post.classList.add("starred");
                        } else {
                            post.classList.remove("starred");
                        }
                    });
                });

                return star;
            }

            function updateStarAppearance(star, postId) {
                if (starredPosts.includes(postId)) {
                    star.innerHTML = "★";
                    star.classList.add("starred");
                } else {
                    star.innerHTML = "☆";
                    star.classList.remove("starred");
                }
            }

            posts.forEach(post => {
                let postId = post.querySelector("h2").innerText;
                let star = createStarElement(postId);
                post.appendChild(star);
                post.setAttribute("data-post-id", postId);
                if (starredPosts.includes(postId)) {
                    post.classList.add("starred");
                }
            });

            let expandedPost = null;

            function expandPost(post) {
                if (expandedPost) return;

                document.body.style.overflow = 'hidden';
                overlay.style.display = "block";

                let postId = post.querySelector("h2").innerText;
                expandedPost = post.cloneNode(true);
                expandedPost.classList.add("expanded-post");
                expandedPost.setAttribute("data-post-id", postId);
                expandedPost.onclick = null;
                expandedPost.querySelector(".read-more").style.display = "none";

                let expandedContent = expandedPost.querySelector(".expanded-content");
                if (expandedContent) {
                    expandedContent.style.display = "block";
                }

                let closeButton = document.createElement("div");
                closeButton.innerHTML = "&times;";
                closeButton.classList.add("close-btn");
                closeButton.onclick = function () {
                    document.body.removeChild(expandedPost);
                    expandedPost = null;
                    document.body.style.overflow = 'auto';
                    overlay.style.display = "none";
                };

                let star = createStarElement(postId);
                expandedPost.appendChild(star);

                expandedPost.appendChild(closeButton);
                document.body.appendChild(expandedPost);
            }

            document.querySelectorAll(".blog-post").forEach(post => {
                post.addEventListener("click", function () {
                    expandPost(this);
                });
            });
        });

    </script>
</body>

</html>