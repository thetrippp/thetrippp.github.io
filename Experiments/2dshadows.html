<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Procedural Shadow Mesh Generation</title>

    <link rel="icon" type="image/x-icon" href="Images/joystick.png"> 
    <link rel="stylesheet" href="2dshadows.css">


</head>
<body>
    <div class="main_div"></div>
        <a href="experiments.html" class="back">Back to Experiments</a>
        <div class="main_description">
            <h1 class="main_Title">Procedural Shadow Caster Generation</h1>
            <p class="main_description">
                An extension to my <a href="2DLights.html" class="experiment_link">lights experiment</a>, cause you can't have lights without shadows :)<br>
                As I understand, shadow caster meshes are generated behind the scenes when working in 2D with lights in the Unity game engine. 
                I thought this would be a great opportunity to explore stencil buffers and the fascinating topic of Geometry Shaders!<br>
            </p> 

            <div class="row">
                <img class="three" src="Images/Geometry Shader Triangle Goal.png">
                <img class="three" src="Images/Geometry Shader Goal.png">
            </div>
            <p class="main_content">
                Contruction of the shadow caster mesh works in 8 stages:<br>
                &emsp;1. For every triangle in the mesh add 2 more points as shown in the first image above.<br>
                &emsp;2. Join the new points to the existing points as shown to form 2 new triangles.<br>
                &emsp;3. Set the normals of the new vertices to be the same as the closest surface as shown(in yellow).<br>
                &emsp;4. Find a vector from each vertex to the light source's position.<br>
                &emsp;5. Calculate the dot product between the vertices' normals and the vector to the light position.<br>
                &emsp;6. Get all vertices whose dot product is negative.<br>
                &emsp;(This means that the surface is facing away from the light.)<br>
                &emsp;7. Project these vertices in the opposite direction to the light.<br>
                &emsp;8. Shade the mesh appropriately to get "SHADOWS!!" *cue angel sounds*.<br><br><br>
            </p> 
            

            <img src="Images/End Result.png" class="four">

            <p class="main_content_center">
                Tested only with very basic meshes. Preliminary tests suggest the current system I have will only work for <br>
                convex neshes, but need to test further and confirm. I also havent taken rotations into account, so rotating<br>
                the mesh for now give weird artifacting. Performance is excellent, also because I'm working with just a handful <br>
                of vertices. 
            </p> 
            <p class="main_content_center">
               Highly inspired by <b>Noel Berry</b>, the brilliant programmer that built the lights and other system for <b>Celeste!</b><br>
               Although he built his system with textures and I'm using mesh manipulation, I feel like this experiment helped me<br>
               clear an important hurdle, starting to use geometry shaders, and I think that is awesome in it's own regard.
            </p>

            <br>
            <p class="main_content_center">
                "Shadows" being cast against the "light". Works smoothly even when the mesh is scaled.
            </p>
            <video width=75% height=75% controls loop="" muted="" autoplay="">
                <source src="https://github.com/thetrippp/thetrippp.github.io/raw/refs/heads/main/Shadows%20Demo.mp4">
            </video>
            <p class="main_content_center">
                I will continue working on this concept and eventually have a working implementation of texture-based 2D lights,<br>
                but until then, Cheers!
                <br>T
             </p>
             <br>
             <br>
             <br>
             <br>
             <br>
        </div>
        
        
    </div>
</body>
</html>